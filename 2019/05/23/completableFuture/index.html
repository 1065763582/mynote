<!DOCTYPE html>












  


<html class="theme-next mist use-motion" lang>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
























<link rel="stylesheet" href="/mynote/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/mynote/css/main.css?v=7.1.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/mynote/images/apple-touch-icon-next.png?v=7.1.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/mynote/images/favicon-32x32-next.png?v=7.1.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/mynote/images/favicon-16x16-next.png?v=7.1.0">


  <link rel="mask-icon" href="/mynote/images/logo.svg?v=7.1.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/mynote/',
    scheme: 'Mist',
    version: '7.1.0',
    sidebar: {"position":"left","display":"hide","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="CompletableFuture实现了Future和CompletionStage，Future意味着CompletableFuture可获取异步计算结果和状态，CompletionStage意味着CompletableFuture可以将异步计算分为多个阶段（Stage） java.util.concurrent.CompletableFutureJDK注释：实现了Future接口（设置其值和状">
<meta name="keywords" content="java,juc">
<meta property="og:type" content="article">
<meta property="og:title" content="CompletableFuture">
<meta property="og:url" content="https://1065763582.github.io/mynote/2019/05/23/completableFuture/index.html">
<meta property="og:site_name" content="Note">
<meta property="og:description" content="CompletableFuture实现了Future和CompletionStage，Future意味着CompletableFuture可获取异步计算结果和状态，CompletionStage意味着CompletableFuture可以将异步计算分为多个阶段（Stage） java.util.concurrent.CompletableFutureJDK注释：实现了Future接口（设置其值和状">
<meta property="og:locale" content="default">
<meta property="og:image" content="https://s2.ax1x.com/2019/06/02/V8hLMq.png">
<meta property="og:image" content="https://s2.ax1x.com/2019/05/26/VAvZ6S.png">
<meta property="og:image" content="https://s2.ax1x.com/2019/05/26/VE160g.png">
<meta property="og:updated_time" content="2019-06-02T07:20:32.259Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="CompletableFuture">
<meta name="twitter:description" content="CompletableFuture实现了Future和CompletionStage，Future意味着CompletableFuture可获取异步计算结果和状态，CompletionStage意味着CompletableFuture可以将异步计算分为多个阶段（Stage） java.util.concurrent.CompletableFutureJDK注释：实现了Future接口（设置其值和状">
<meta name="twitter:image" content="https://s2.ax1x.com/2019/06/02/V8hLMq.png">





  
  
  <link rel="canonical" href="https://1065763582.github.io/mynote/2019/05/23/completableFuture/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>CompletableFuture | Note</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/mynote/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Note</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/mynote/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>Home</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/mynote/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>Archives</a>

  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://1065763582.github.io/mynote/mynote/2019/05/23/completableFuture/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="哩厘理濿">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/mynote/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Note">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">CompletableFuture

              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-05-23 21:02:06" itemprop="dateCreated datePublished" datetime="2019-05-23T21:02:06+08:00">2019-05-23</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-06-02 15:20:32" itemprop="dateModified" datetime="2019-06-02T15:20:32+08:00">2019-06-02</time>
              
            
          </span>

          

          
            
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="post-meta-item-icon">
            <i class="fa fa-eye"></i>
             Views:  
            <span class="busuanzi-value" id="busuanzi_value_page_pv"></span>
            </span>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>CompletableFuture实现了Future和CompletionStage，Future意味着CompletableFuture可获取异步计算结果和状态，CompletionStage意味着CompletableFuture可以将异步计算分为多个阶段（Stage）</p>
<h1 id="java-util-concurrent-CompletableFuture"><a href="#java-util-concurrent-CompletableFuture" class="headerlink" title="java.util.concurrent.CompletableFuture"></a>java.util.concurrent.CompletableFuture<t></t></h1><p>JDK注释：实现了Future接口（设置其值和状态），并且可以用作CompletionStage，支持在完成时触发依赖函数和操作。当两个或多个线程尝试完成，异常完成或取消CompletableFuture时，只有其中一个成功。除了直接操作状态和结果的这些相关方法之外，CompletableFuture还使用以下策略实现接口CompletionStage：</p>
<ol>
<li>非异步类型的完成方法可以由完成当前CompletableFuture的线程执行，或者由完成方法的任何其他调用者执行。</li>
<li>所有没有Executor参数的异步方法都是使用ForkJoinPool.commonPool（）执行的（除非它不支持两个并行级别，在这种情况下，创建一个新的Thread来运行每个任务）。为了简化监视，调试和跟踪，所有生成的异步任务都是接口CompletableFuture.AsynchronousCompletionTask的实例。</li>
<li>所有CompletionStage方法都是独立于其他公共方法实现的，因此一个方法的行为不会受到子类中其他方法的覆盖的影响。</li>
</ol>
<p>CompletableFuture还通过以下策略实现Future：</p>
<ol>
<li>与FutureTask不同，由于此类无法直接控制导致其完成的计算，因此取消仅被视为异常完成的另一种形式。 cancel方法效果和completeExceptionally（new CancellationException（））相同。 方法isCompletedExceptionally可用于确定CompletableFuture是否以任何异常方式完成。</li>
<li>如果使用CompletionException进行异常完成，则方法get（）和get（long，TimeUnit）抛出ExecutionException，其原因与相应的CompletionException中保持的原因相同。 为了简化大多数上下文的使用，此类还定义了join（）和getNow方法，它们在这些情况下直接抛出CompletionException。</li>
</ol>
<p>概述：CompletableFuture可能会依赖一些列完成操作，这些操作被收集在链接堆栈中。 它通过CAS更新<strong>result</strong>字段以原子方式完成，然后弹出并运行这些操作。这适用于正常与异常结果，同步与异步动作，二进制触发器和各种形式的完成动作。<br>字段<strong>result</strong>的非零值（通过CAS设置）表示已完成。 AltResult用于将null作为结果，以及保存异常。使用单个字段可以试完成动作的发现和触发变得简单。编码和解码很简单，但会增加陷阱并将异常与目标相关联。使用静态变量NIL简化了NULL值，用AltResult（<code>new AltResult(null);</code>）表示,因此我们通常不需要进行显式比较。<br>每个计算动作由作为Treiber堆栈链接的<strong>Completion</strong>对象表示，该堆栈由字段<strong>stack</strong>为首。每种动作都有完成类，分为单输入（UniCompletion），双输入（BiCompletion），投影（BiCompletions使用两个输入中的两个或一个），共享（CoCompletion，由两个中的第二个使用） 来源），零输入源动作，以及没有阻塞的信号量。类完成扩展了ForkJoinTask以启用异步执行（不添加空间开销，因为我们利用其“标记”方法来维护声明）。 它也被声明为Runnable以允许使用任意执行程序。 对每种CompletionStage的支持依赖于一个单独的类，以及两个CompletableFuture方法：</p>
<ol>
<li>名称为X的Completion类，对应的方法以“Uni”，“Bi”或“Or”开头。每个类都包含源，操作和依赖项的字段。 它们非常相似，仅与底层功能形式有所不同。 我们这样做是为了让用户在常见用法中不会遇到适配器层。 我们还包括与用户方法不对应的“Relay”类/方法， 他们将结果从一个阶段复制到另一个阶段。</li>
<li>Boolean CompletableFuture method x(…)方法，例如uniApply，获取所有需要的参数检查动作是否应该被触发，然后运行操作或通过执行其Completion参数（如果存在）安排的异步执行。 如果已知完成，则该方法返回true。</li>
<li>完成方法tryFire（int mode）使用其保持的参数调用关联的x方法，并在成功时清除。 mode参数允许tryFire被调用两次（SYNC，然后是ASYNC）; 第一个在安排执行时屏蔽和捕获异常，第二个在从任务调用时触发异常。 （一些类不使用异步，因此采用略有不同的形式。）如果另一个线程声明了，则claim（）回调会抑制函数调用。</li>
<li>CompletableFuture方法xStage（…）从CompletableFuture x的公共stage方法调用。 它会筛选用户参数并调用和/或创建stage对象。 如果不是异步并且x已经完成，则立即执行操作。 否则，创建Completion c，推送到x的堆栈（除非完成），并通过c.tryFire启动或触发。 如果x在入栈时完成，这也包括可能的竞争。具有两个输入的类（例如BiApply）在入栈动作时处理两者之间的竞争。 第二个completion是CoCompletion指向第一个，共享，以便最多只执行一个动作。 多重方法allOf和anyOf成对地形成Completion树。</li>
</ol>
<p>请注意，方法的泛型类型参数根据“this”是源，依赖还是完成而有所不同。方法postComplete在完成时被调用，除非保证目标不可观察（即，尚未返回或链接）。 多个线程可以调用postComplete，它会自动弹出每个依赖操作，并尝试在NESTED模式下通过方法tryFire触发它。 触发可以递归传播，因此NESTED模式返回其完成的依赖（如果存在）以供其调用者进一步处理（请参阅postFire方法）。 阻塞方法get（）和join（）依赖于唤醒等待线程的Signaller Completions。 这些机制类似于FutureTask，Phaser和SynchronousQueue中使用的Treiber堆栈等待节点。 有关算法详细信息，请参阅其内部文档。<br>如果没有预防措施，CompletableFutures将容易进行垃圾堆积，因为完成链的堆积，每个都指向其源。 所以我们尽快将字段置为null（特别参见方法Completion.detach）。 无论如何，筛选检查无害地忽略了在使用线程将字段置null的竞争期间可能获得的空参数。 我们还尝试从可能永远不会弹出的堆栈中取消链接已触发的完成（请参阅方法postFire）。 Completion字段不需要声明为final或volatile，因为它们仅在安全发布时对其他线程可见。</p>
<h2 id="源码功能概览："><a href="#源码功能概览：" class="headerlink" title="源码功能概览："></a>源码功能概览：</h2><ol>
<li>若某一阶段出现异常，那么此阶段后的所有阶段都会异常</li>
<li>Run系列的阶段，计算结果一定为NIL</li>
<li>线程的顺序是基于栈实现的，同样获取结果的等待get方法也是基于栈</li>
<li>从线程关系组织角度看：串行-then，compose;等待所有-Combine，Both;等待任意一个-Either;</li>
<li>从计算形式角度看：Apply-计算接收参数并返回新的计算结果;Accept-计算接收参数，但不返回;Run-计算不接收参数也不返回;</li>
<li>从执行线程看：Async-在线程池异步执行; 没有Async-同步执行</li>
<li>异步执行的函数有重载：一种使用默认线程池，一个使用自定义线程池</li>
<li>线程的顺序是基于栈实现的，同样获取结果的等待get方法也是基于栈,如图所示：<br><img src="https://s2.ax1x.com/2019/06/02/V8hLMq.png" alt="stack"></li>
<li>基于next的路线，计算会出栈立刻执行，相互之间没有联系，执行顺序也没有保证</li>
<li>基于dep.next的路线，计算是顺序执行，一定是前一个计算完成才开始后一个计算<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 结果或封装的AltResult。</span></span><br><span class="line"><span class="comment"> * 若正常结束，result存计算结果，</span></span><br><span class="line"><span class="comment"> * 若计算结果是null， result为AltResult实例 NIL</span></span><br><span class="line"><span class="comment"> * 若异常结果，result为AltResult实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">volatile</span> Object result; </span><br><span class="line"><span class="comment">// 依赖行为的Treiber stack</span></span><br><span class="line"><span class="keyword">volatile</span> Completion stack;</span><br><span class="line"><span class="comment">// 表示空置null</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> AltResult NIL = <span class="keyword">new</span> AltResult(<span class="keyword">null</span>);</span><br><span class="line"><span class="comment">// 判断是否支持并行，用于决定默认线程池类型</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> useCommonPool = (ForkJoinPool.getCommonPoolParallelism() &gt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Completion.tryFire的模式</span></span><br><span class="line"><span class="comment">// 同步模式</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SYNC   =  <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 异步模式</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ASYNC  =  <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 内嵌模式</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NESTED = -<span class="number">1</span>;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="标识接口"><a href="#标识接口" class="headerlink" title="标识接口"></a>标识接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 标识异步方法生成的异步任务的标记接口。 </span></span><br><span class="line"><span class="comment"> * 这可用于监视，调试和跟踪异步</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">interface</span> <span class="title">AsynchronousCompletionTask</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="空置和异常"><a href="#空置和异常" class="headerlink" title="空置和异常"></a>空置和异常</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于编码null值和异常值，null值只用NIL表示</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">AltResult</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Throwable ex;</span><br><span class="line">    AltResult(Throwable x) &#123; <span class="keyword">this</span>.ex = x; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="栈-Completion"><a href="#栈-Completion" class="headerlink" title="栈 - Completion"></a>栈 - Completion</h2><p>一个Completion表示栈中的一个计算，next指向栈的下一个元素<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ------------- 基于Completion的操作 -------------- */</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"serial"</span>)</span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Completion</span> <span class="keyword">extends</span> <span class="title">ForkJoinTask</span>&lt;<span class="title">Void</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Runnable</span>, <span class="title">AsynchronousCompletionTask</span> </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> Completion next;      <span class="comment">// Treiber stack link</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果触发，则执行完成操作，返回可能需要传播的依赖项（如果存在）。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mode SYNC, ASYNC, or NESTED</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">abstract</span> CompletableFuture&lt;?&gt; tryFire(<span class="keyword">int</span> mode);</span><br><span class="line">    <span class="comment">/** 如果可能仍然可触发，则返回true。 由cleanStack使用。 */</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">isLive</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 重写run方法，由普通的线程池执行</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span>                </span>&#123; tryFire(ASYNC); &#125;</span><br><span class="line">    <span class="comment">// 重写exec方法， 由ForkJoinPool线程池执行</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">exec</span><span class="params">()</span>            </span>&#123; tryFire(ASYNC); <span class="keyword">return</span> <span class="keyword">true</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Void <span class="title">getRawResult</span><span class="params">()</span>       </span>&#123; <span class="keyword">return</span> <span class="keyword">null</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setRawResult</span><span class="params">(Void v)</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置Completion的NEXT</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">lazySetNext</span><span class="params">(Completion c, Completion next)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 不保证值的改变被其他线程立即看到。</span></span><br><span class="line">    <span class="comment">// 只有在field被volatile修饰并且期望被意外修改的时候使用才有用</span></span><br><span class="line">    UNSAFE.putOrderedObject(c, NEXT, next);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 弹出并尝试触发所有可到达的依赖项。</span></span><br><span class="line"><span class="comment"> * 此操作会唤醒在当前CompletableFuture的栈上所有的计算，随后尝试执行。</span></span><br><span class="line"><span class="comment"> * 注意： 在同一个CompeltableFuture上then或者其他操作是没有顺序性的，</span></span><br><span class="line"><span class="comment"> * 当前阶段完成后，所有依赖与此阶段的计算会全部开始执行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">postComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 在每个步骤中，变量f将当前依赖项保存为弹出和运行。 </span></span><br><span class="line"><span class="comment">     * 它一次只沿一条路径扩展，推动其他路径以避免无限制的递归。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    CompletableFuture&lt;?&gt; f = <span class="keyword">this</span>; Completion h;</span><br><span class="line">    <span class="keyword">while</span> ((h = f.stack) != <span class="keyword">null</span> ||</span><br><span class="line">           (f != <span class="keyword">this</span> &amp;&amp; (h = (f = <span class="keyword">this</span>).stack) != <span class="keyword">null</span>)) &#123;</span><br><span class="line">        CompletableFuture&lt;?&gt; d; Completion t;</span><br><span class="line">        <span class="keyword">if</span> (f.casStack(h, t = h.next)) &#123;</span><br><span class="line">            <span class="comment">// 当前栈顶元素不为空，就出栈</span></span><br><span class="line">            <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (f != <span class="keyword">this</span>) &#123;</span><br><span class="line">                    pushStack(h);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                h.next = <span class="keyword">null</span>;    <span class="comment">// detach</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 出栈后开始执行</span></span><br><span class="line">            f = (d = h.tryFire(NESTED)) == <span class="keyword">null</span> ? <span class="keyword">this</span> : d;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** Traverses stack and unlinks dead Completions. */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">cleanStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Completion p = <span class="keyword">null</span>, q = stack; q != <span class="keyword">null</span>;) &#123;</span><br><span class="line">        Completion s = q.next;</span><br><span class="line">        <span class="keyword">if</span> (q.isLive()) &#123;</span><br><span class="line">            p = q;</span><br><span class="line">            q = s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p == <span class="keyword">null</span>) &#123;</span><br><span class="line">            casStack(q, s);</span><br><span class="line">            q = stack;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            p.next = s;</span><br><span class="line">            <span class="keyword">if</span> (p.isLive())</span><br><span class="line">                q = s;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p = <span class="keyword">null</span>;  <span class="comment">// restart</span></span><br><span class="line">                q = stack;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h1><h2 id="runAsync"><a href="#runAsync" class="headerlink" title="runAsync"></a>runAsync</h2><p>run系列的异步计算既不会接收前一阶段的参数，也不会产生新的计算结果。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回一个新的CompletableFuture，它在运行给定操作后由ForkJoinPool.commonPool（）中运行的任务异步完成runnable。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> runnable 异步计算任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回新的CompletableFuture</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title">runAsync</span><span class="params">(Runnable runnable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> asyncRunStage(asyncPool, runnable);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造一个异步运行的Stage，并且使用类AsyncRun将Stage与异步计算f关联</span></span><br><span class="line"><span class="comment"> * 然后放到线程池异步执行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title">asyncRunStage</span><span class="params">(Executor e, Runnable f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">// 每个异步计算，都对于一个新的阶段Stage</span></span><br><span class="line">    CompletableFuture&lt;Void&gt; d = <span class="keyword">new</span> CompletableFuture&lt;Void&gt;();</span><br><span class="line">    <span class="comment">// 将异步计算放入线程池</span></span><br><span class="line">    e.execute(<span class="keyword">new</span> AsyncRun(d, f));</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="AsyncRun"><a href="#AsyncRun" class="headerlink" title="AsyncRun"></a>AsyncRun</h3><p>此类的作用有两个：</p>
<ol>
<li>关联CompletableFuture与Runnable，理解为将异步计算关联到一个阶段（stage）上。</li>
<li>实现了Runnable的run和ForkJoinTask的exec，用于在不同的线程池中异步执行</li>
</ol>
<p><img src="https://s2.ax1x.com/2019/05/26/VAvZ6S.png" alt></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"serial"</span>)</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncRun</span> <span class="keyword">extends</span> <span class="title">ForkJoinTask</span>&lt;<span class="title">Void</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Runnable</span>, <span class="title">AsynchronousCompletionTask</span> </span>&#123;</span><br><span class="line">    CompletableFuture&lt;Void&gt; dep; Runnable fn;</span><br><span class="line">    <span class="comment">// 一个阶段Stage关联一个异步计算fn</span></span><br><span class="line">    AsyncRun(CompletableFuture&lt;Void&gt; dep, Runnable fn) &#123;</span><br><span class="line">        <span class="keyword">this</span>.dep = dep; <span class="keyword">this</span>.fn = fn;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*************重写的ForkJoinTask方法***************/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Void <span class="title">getRawResult</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">null</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setRawResult</span><span class="params">(Void v)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">exec</span><span class="params">()</span> </span>&#123; run(); <span class="keyword">return</span> <span class="keyword">true</span>; &#125;</span><br><span class="line">    <span class="comment">/*************重写的ForkJoinTask方法***************/</span></span><br><span class="line">    <span class="comment">// 无论用什么线程池，最终调用的都是同样的计算过程</span></span><br><span class="line">    <span class="comment">/*************重写的Runnable方法***************/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CompletableFuture&lt;Void&gt; d; Runnable f;</span><br><span class="line">        <span class="comment">// 属性检查</span></span><br><span class="line">        <span class="keyword">if</span> ((d = dep) != <span class="keyword">null</span> &amp;&amp; (f = fn) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            dep = <span class="keyword">null</span>; fn = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 若结果为空，表示该计算还未完成</span></span><br><span class="line">            <span class="keyword">if</span> (d.result == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 执行runnable的异步计算</span></span><br><span class="line">                    f.run();</span><br><span class="line">                    <span class="comment">// 因为run系列不会产生新的计算结果，因此需要将结果设置为空</span></span><br><span class="line">                    d.completeNull();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                    <span class="comment">// 若异常，则需要将结果设为一个异常标识</span></span><br><span class="line">                    d.completeThrowable(ex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 完成处理</span></span><br><span class="line">            d.postComplete();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>f.run();</code>表示我们自己的业务处理方法。执行后调用了CompletableFuture的三个方法，<code>d.completeNull();</code>表示正常结束将结果置为NIL，<code>d.completeThrowable(ex);</code>表示异常结束并将异常封装到AltResult中。无论异常结束还是正常结束，都会执行<code>d.postComplete();</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 使用NIL表示run的完成</span></span><br><span class="line"><span class="comment"> * 若已完成则更新失败</span></span><br><span class="line"><span class="comment"> * 可能多个线程同时允许此任务，先完成的更新RESULT，其他线程CAS失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">completeNull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, RESULT, <span class="keyword">null</span>,</span><br><span class="line">                                       NIL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 异常结束，将异常封装到AltResult中 */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">completeThrowable</span><span class="params">(Throwable x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, RESULT, <span class="keyword">null</span>,</span><br><span class="line">                                       encodeThrowable(x));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 编码异常</span></span><br><span class="line"><span class="comment"> * 最终所有异常都封装为CompletionException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> AltResult <span class="title">encodeThrowable</span><span class="params">(Throwable x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AltResult((x <span class="keyword">instanceof</span> CompletionException) ? x :</span><br><span class="line">                         <span class="keyword">new</span> CompletionException(x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="supplyAsync"><a href="#supplyAsync" class="headerlink" title="supplyAsync"></a>supplyAsync</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回一个新的CompetableFuture</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> supplier 可以返回值的计算过程</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;U&gt; 返回值类型</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 新的CompetableFuture</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; <span class="title">supplyAsync</span><span class="params">(Supplier&lt;U&gt; supplier)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> asyncSupplyStage(asyncPool, supplier);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行过程和run系列类似，但是提交到线程池的类不一样,这里使用<code>AsyncSupply</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; <span class="title">asyncSupplyStage</span><span class="params">(Executor e,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                 Supplier&lt;U&gt; f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    CompletableFuture&lt;U&gt; d = <span class="keyword">new</span> CompletableFuture&lt;U&gt;();</span><br><span class="line">    e.execute(<span class="keyword">new</span> AsyncSupply&lt;U&gt;(d, f));</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="AsyncSupply"><a href="#AsyncSupply" class="headerlink" title="AsyncSupply"></a>AsyncSupply</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncSupply</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ForkJoinTask</span>&lt;<span class="title">Void</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Runnable</span>, <span class="title">AsynchronousCompletionTask</span> </span>&#123;</span><br><span class="line">    CompletableFuture&lt;T&gt; dep; Supplier&lt;T&gt; fn;</span><br><span class="line">    <span class="comment">// dep 是依赖的阶段，  fn是此过程执行的计算</span></span><br><span class="line">    AsyncSupply(CompletableFuture&lt;T&gt; dep, Supplier&lt;T&gt; fn) &#123;</span><br><span class="line">        <span class="keyword">this</span>.dep = dep; <span class="keyword">this</span>.fn = fn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Void <span class="title">getRawResult</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">null</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setRawResult</span><span class="params">(Void v)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">exec</span><span class="params">()</span> </span>&#123; run(); <span class="keyword">return</span> <span class="keyword">true</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CompletableFuture&lt;T&gt; d; Supplier&lt;T&gt; f;</span><br><span class="line">        <span class="keyword">if</span> ((d = dep) != <span class="keyword">null</span> &amp;&amp; (f = fn) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            dep = <span class="keyword">null</span>; fn = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (d.result == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// f.get() 调用计算过程，然后CAS更新执行结果</span></span><br><span class="line">                    d.completeValue(f.get());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                    <span class="comment">// 若出现异常，则将执行结果封装</span></span><br><span class="line">                    d.completeThrowable(ex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 唤醒栈上的计算</span></span><br><span class="line">            d.postComplete();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="completedFuture"><a href="#completedFuture" class="headerlink" title="completedFuture"></a>completedFuture</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回一个已经完成的CompletableFuture，计算结果为Value</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 计算结果</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;U&gt; 计算结果类型</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the completed CompletableFuture</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; <span class="title">completedFuture</span><span class="params">(U value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CompletableFuture&lt;U&gt;((value == <span class="keyword">null</span>) ? NIL : value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="anyOf"><a href="#anyOf" class="headerlink" title="anyOf"></a>anyOf</h2><p>接收一组CompletableFuture，<strong>任何一个</strong>完成了那么新的CompletableFuture也完成了，计算结果同完成的CompletableFuture。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回一个新的CompletableFuture，它在任何给定的CompletableFutures完成时完成，结果相同。 </span></span><br><span class="line"><span class="comment"> * 如果异常完成，则返回的CompletableFuture也会这样做，并且CompletionException将此异常作为其原因。</span></span><br><span class="line"><span class="comment"> * 如果未提供CompletableFutures，则返回不完整的CompletableFuture。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> cfs 多个CompletableFuture</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 一个新的CompletableFuture，当完成时，它与任何给定的CompletableFutures的结果或异常一起完成</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the array or any of its elements are</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> null&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Object&gt; <span class="title">anyOf</span><span class="params">(CompletableFuture&lt;?&gt;... cfs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> orTree(cfs, <span class="number">0</span>, cfs.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="allOf"><a href="#allOf" class="headerlink" title="allOf"></a>allOf</h2><p>接收一组CompletableFuture，<strong>全部完成</strong>了那么新的CompletableFuture也完成了<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回在所有给定的CompletableFutures完成时完成的新CompletableFuture。 </span></span><br><span class="line"><span class="comment"> * 如果任何给定的CompletableFutures异常完成，则返回的CompletableFuture也会这样做，</span></span><br><span class="line"><span class="comment"> * 并且CompletionException将此异常作为其原因。 否则，给定的CompletableFutures的结果（如果有的话）</span></span><br><span class="line"><span class="comment"> * 不会反映在返回的CompletableFuture中，但可以通过单独检查它们来获得。 </span></span><br><span class="line"><span class="comment"> * 如果未提供CompletableFutures，则返回CompletableFuture，其值为null。</span></span><br><span class="line"><span class="comment"> * 此方法的应用之一是在继续程序之前等待完成一组独立的CompletableFutures，</span></span><br><span class="line"><span class="comment"> * 如：CompletableFuture.allOf（c1，c2，c3）.join（）;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> cfs 一组CompletableFuture</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 在所有给定的CompletableFutures完成时完成的新CompletableFuture</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the array or any of its elements are</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> null&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title">allOf</span><span class="params">(CompletableFuture&lt;?&gt;... cfs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> andTree(cfs, <span class="number">0</span>, cfs.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="线程间的关系"><a href="#线程间的关系" class="headerlink" title="线程间的关系"></a>线程间的关系</h1><h2 id="then-uniRunStage"><a href="#then-uniRunStage" class="headerlink" title="then - uniRunStage"></a>then - uniRunStage</h2><p>等待前一阶段完成后开始后一阶段。<br>then系列执行时，计算会先尝试运行一次，先判断当前CompletableFurure计算是否完成，若未完成则入栈（completableFuture.stack）若完成则执行计算，然后返回一个代表then系列计算的阶段（CompletableFuture）。需要注意，CompletableFurure使用栈保存计算，意味着栈顶计算会先执行，但栈后面的计算并不会等栈顶计算完成才开始，而是出栈就开始，也就是说同一个栈内的计算并没有相互依赖的关系，他们只依赖于栈的持有者CompletableFurure。<br>还需要注意，同步then系列的执行线程，若前一个异步阶段执行完后，才执行then方法，那么then方法所表示的计算执行线程是在调用then方法的线程中执行，否则会在异步阶段的线程中执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当前一阶段计算完成后，在当前调用线程同步执行action计算</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title">thenRun</span><span class="params">(Runnable action)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> uniRunStage(<span class="keyword">null</span>, action);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当前一阶段计算完成后，在默认线程池异步执行action计算</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title">thenRunAsync</span><span class="params">(Runnable action)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> uniRunStage(asyncPool, action);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当前一阶段计算完成后，在指定线程池异步执行action计算</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title">thenRunAsync</span><span class="params">(Runnable action,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            Executor executor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> uniRunStage(screenExecutor(executor), action);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  空值检查，并在禁用并行性的情况下将commonPool的用法转换为asyncPool。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Executor <span class="title">screenExecutor</span><span class="params">(Executor e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!useCommonPool &amp;&amp; e == ForkJoinPool.commonPool())</span><br><span class="line">        <span class="keyword">return</span> asyncPool;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 执行一个计算，返回新的CompletableFuture</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 计算执行的线程池，若为null，则表示在调用线程执行，而不会在其他线程执行</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> f 自定义的计算过程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> CompletableFuture&lt;Void&gt; <span class="title">uniRunStage</span><span class="params">(Executor e, Runnable f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">// 一个计算对应一个阶段stage</span></span><br><span class="line">    CompletableFuture&lt;Void&gt; d = <span class="keyword">new</span> CompletableFuture&lt;Void&gt;();</span><br><span class="line">    <span class="comment">// 线程池不会空，表示需要异步执行， 若线程池为空则调用方法uniRun执行此计算f</span></span><br><span class="line">    <span class="comment">// 有两种情况下需要先将阶段d入栈</span></span><br><span class="line">    <span class="comment">// 1. e != null 表示需要异步执行，需要先将d入栈</span></span><br><span class="line">    <span class="comment">// 2. uniRun 返回false， 即前一个阶段没有执行完成</span></span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span> || !d.uniRun(<span class="keyword">this</span>, f, <span class="keyword">null</span>)) &#123;</span><br><span class="line">        <span class="comment">// 将新的阶段封装一个栈上的数据</span></span><br><span class="line">        UniRun&lt;T&gt; c = <span class="keyword">new</span> UniRun&lt;T&gt;(e, d, <span class="keyword">this</span>, f);</span><br><span class="line">        <span class="comment">// 入栈</span></span><br><span class="line">        push(c);</span><br><span class="line">        <span class="comment">// 调用计算</span></span><br><span class="line">        c.tryFire(SYNC);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** 将一个新的阶段入栈 */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(UniCompletion&lt;?,?&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (c != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (result == <span class="keyword">null</span> &amp;&amp; !tryPushStack(c))</span><br><span class="line">            lazySetNext(c, <span class="keyword">null</span>); <span class="comment">// 失败就清除c.next</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 入栈成功返回true */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryPushStack</span><span class="params">(Completion c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前阶段的栈顶</span></span><br><span class="line">    Completion h = stack;</span><br><span class="line">    <span class="comment">// 将c.next 设为 h</span></span><br><span class="line">    lazySetNext(c, h);</span><br><span class="line">    <span class="comment">// 将栈顶设为C</span></span><br><span class="line">    <span class="keyword">return</span> UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, STACK, h, c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">lazySetNext</span><span class="params">(Completion c, Completion next)</span> </span>&#123;</span><br><span class="line">    UNSAFE.putOrderedObject(c, NEXT, next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  执行计算f，并将计算与CompletableFuture关联</span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@param</span> a 前一个阶段</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@param</span> f 当前阶段需要执行的计算过程</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@param</span> c 当前阶段的栈元素</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@return</span> true 计算执行完成， false表示计算未执行</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">uniRun</span><span class="params">(CompletableFuture&lt;?&gt; a, Runnable f, UniRun&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 前一阶段的执行结果</span></span><br><span class="line">    Object r; </span><br><span class="line">    <span class="comment">// 前一阶段的执行异常</span></span><br><span class="line">    Throwable x;</span><br><span class="line">    <span class="comment">// 参数检查，  若 a.result == null 则表示前一阶段还没有执行完</span></span><br><span class="line">    <span class="keyword">if</span> (a == <span class="keyword">null</span> || (r = a.result) == <span class="keyword">null</span> || f == <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// 返回false，表示未执行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// result 为空表示当前计算未执行完成，需要执行此计算</span></span><br><span class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 在计算前先判断，若前一阶段执行异常，则直接异常结束计算</span></span><br><span class="line">        <span class="comment">// AltResult编码了NULL和异常，若ex不为空，那么一定是前一计算阶段异常了</span></span><br><span class="line">        <span class="keyword">if</span> (r <span class="keyword">instanceof</span> AltResult &amp;&amp; (x = ((AltResult)r).ex) != <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">// 包装异常</span></span><br><span class="line">            <span class="comment">// 返回ture</span></span><br><span class="line">            completeThrowable(x, r);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (c != <span class="keyword">null</span> &amp;&amp; !c.claim())</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="comment">// 执行当前阶段的计算</span></span><br><span class="line">                f.run();</span><br><span class="line">                <span class="comment">// 正常结束，将当前阶段执行结果置空</span></span><br><span class="line">                completeNull();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                <span class="comment">// 异常结束，将当前阶段执行的异常编码存储</span></span><br><span class="line">                completeThrowable(ex);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前阶段的计算只要执行了，无论异常还是正常结束，都返回true</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出过程是先执行一次（uniRun），若前一个线程结果没有结束（result == null ）就返回false，然后封装为UniRun类，当前CompletableFuture的stack，作为栈顶，随后立即尝试再次调用，若无法调用就在栈中等待，若调用成功就清除栈中已完成的计算</p>
<h3 id="UniRun"><a href="#UniRun" class="headerlink" title="UniRun"></a>UniRun</h3><p><img src="https://s2.ax1x.com/2019/05/26/VE160g.png" alt="UniRun类图"></p>
<p>首先看父类<code>UniCompletion&lt;T,V&gt;</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 带有源，依赖和执行者的Completion。</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"serial"</span>)</span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UniCompletion</span>&lt;<span class="title">T</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Completion</span> </span>&#123;</span><br><span class="line">    Executor executor;                 <span class="comment">// 如果不为空，就会使用此线程池</span></span><br><span class="line">    CompletableFuture&lt;V&gt; dep;          <span class="comment">// 当前阶段对应的CompletableFuture</span></span><br><span class="line">    CompletableFuture&lt;T&gt; src;          <span class="comment">// 前一个阶段</span></span><br><span class="line"></span><br><span class="line">    UniCompletion(Executor executor, CompletableFuture&lt;V&gt; dep,</span><br><span class="line">                  CompletableFuture&lt;T&gt; src) &#123;</span><br><span class="line">        <span class="keyword">this</span>.executor = executor; <span class="keyword">this</span>.dep = dep; <span class="keyword">this</span>.src = src;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果可以运行操作，则返回true。 仅在已知可触发时调用。 </span></span><br><span class="line"><span class="comment">     * 使用FJTag来确保只有一个线程声明所有权。 </span></span><br><span class="line"><span class="comment">     * 如果异步，则作为任务启动 - 稍后调用tryFire将运行操作。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">claim</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Executor e = executor;</span><br><span class="line">        <span class="comment">// 将FJ的标志位设置为1，确保只有一个线程声明所有权</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetForkJoinTaskTag((<span class="keyword">short</span>)<span class="number">0</span>, (<span class="keyword">short</span>)<span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="comment">// e == null  表示是同步方法</span></span><br><span class="line">            <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            executor = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 提交任务执行 </span></span><br><span class="line">            e.execute(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 依赖的阶段不为空，就表示存活</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isLive</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> dep != <span class="keyword">null</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"serial"</span>)</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">UniRun</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">UniCompletion</span>&lt;<span class="title">T</span>,<span class="title">Void</span>&gt; </span>&#123;</span><br><span class="line">    Runnable fn;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * executor: 当前计算执行的线程池</span></span><br><span class="line"><span class="comment">     * dep: 当前计算对应的CompletableFuture</span></span><br><span class="line"><span class="comment">     * src: 前一个计算对应的CompletableFuture</span></span><br><span class="line"><span class="comment">     * fu : 当前计算过程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    UniRun(Executor executor, CompletableFuture&lt;Void&gt; dep,</span><br><span class="line">           CompletableFuture&lt;T&gt; src, Runnable fn) &#123;</span><br><span class="line">        <span class="keyword">super</span>(executor, dep, src); <span class="keyword">this</span>.fn = fn;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 以指定的mode执行计算</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> CompletableFuture&lt;Void&gt; <span class="title">tryFire</span><span class="params">(<span class="keyword">int</span> mode)</span> </span>&#123;</span><br><span class="line">        CompletableFuture&lt;Void&gt; d; CompletableFuture&lt;T&gt; a;</span><br><span class="line">        <span class="comment">// dep == null 表示该阶段不再存活</span></span><br><span class="line">        <span class="comment">// d.uniRun， 执行阶段d的计算，</span></span><br><span class="line">        <span class="comment">// mode &gt; 0 表示异步计算</span></span><br><span class="line">        <span class="keyword">if</span> ((d = dep) == <span class="keyword">null</span> ||</span><br><span class="line">            !d.uniRun(a = src, fn, mode &gt; <span class="number">0</span> ? <span class="keyword">null</span> : <span class="keyword">this</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        dep = <span class="keyword">null</span>; src = <span class="keyword">null</span>; fn = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> d.postFire(a, mode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清理当前阶段的栈</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> CompletableFuture&lt;T&gt; <span class="title">postFire</span><span class="params">(CompletableFuture&lt;?&gt; a, <span class="keyword">int</span> mode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a != <span class="keyword">null</span> &amp;&amp; a.stack != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// mode &lt; 0 表示内嵌模式，表示该计算是在栈中被唤醒</span></span><br><span class="line">        <span class="comment">// a.result == null 前一个计算未完成？</span></span><br><span class="line">        <span class="keyword">if</span> (mode &lt; <span class="number">0</span> || a.result == <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">// 清理前一阶段的栈</span></span><br><span class="line">            a.cleanStack();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 唤醒前一阶段栈上的计算</span></span><br><span class="line">            a.postComplete();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="keyword">null</span> &amp;&amp; stack != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 若是内嵌模式，返回当前对象</span></span><br><span class="line">        <span class="keyword">if</span> (mode &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 否则唤醒当前阶段栈上的计算</span></span><br><span class="line">            postComplete();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Either-orRunStage"><a href="#Either-orRunStage" class="headerlink" title="Either - orRunStage"></a>Either - orRunStage</h2><p>等待两个阶段的任意一个完成后开始新的计算，思路和then相差不多。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title">runAfterEither</span><span class="params">(CompletionStage&lt;?&gt; other,</span></span></span><br><span class="line"><span class="function"><span class="params">                                             Runnable action)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> orRunStage(<span class="keyword">null</span>, other, action);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 执行OR关系的计算，即等待的任何一个任务完成就开始执行新的计算</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 计算执行的线程池，空表示同步执行</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o 另一个计算阶段，等待的对象就是当前计算阶段this和另一个计算阶段o</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> f 执行的计算过程</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 新的CompeltabelFuture</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> CompletableFuture&lt;Void&gt; <span class="title">orRunStage</span><span class="params">(Executor e, CompletionStage&lt;?&gt; o,</span></span></span><br><span class="line"><span class="function"><span class="params">                                           Runnable f)</span> </span>&#123;</span><br><span class="line">    CompletableFuture&lt;?&gt; b;</span><br><span class="line">    <span class="comment">// 参数验证</span></span><br><span class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span> || (b = o.toCompletableFuture()) == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">// 准备一个新的计算阶段</span></span><br><span class="line">    CompletableFuture&lt;Void&gt; d = <span class="keyword">new</span> CompletableFuture&lt;Void&gt;();</span><br><span class="line">    <span class="comment">// 首先尝试运行一次异步任务，若条件不满足则入栈</span></span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span> || !d.orRun(<span class="keyword">this</span>, b, f, <span class="keyword">null</span>)) &#123;</span><br><span class="line">        OrRun&lt;T,?&gt; c = <span class="keyword">new</span> OrRun&lt;&gt;(e, d, <span class="keyword">this</span>, b, f);</span><br><span class="line">        orpush(b, c);</span><br><span class="line">        c.tryFire(SYNC);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 执行OR关系的计算</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> a 前置的计算阶段</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o 另一个前置的计算阶段</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> f 执行的计算过程</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true 计算已经执行完；false 计算目前不能执行 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">orRun</span><span class="params">(CompletableFuture&lt;?&gt; a, CompletableFuture&lt;?&gt; b,</span></span></span><br><span class="line"><span class="function"><span class="params">                    Runnable f, OrRun&lt;?,?&gt; c)</span> </span>&#123;</span><br><span class="line">    Object r; Throwable x;</span><br><span class="line">    <span class="comment">// 若a.result和b.result都为空，那么返回false，</span></span><br><span class="line">    <span class="keyword">if</span> (a == <span class="keyword">null</span> || b == <span class="keyword">null</span> ||</span><br><span class="line">        ((r = a.result) == <span class="keyword">null</span> &amp;&amp; (r = b.result) == <span class="keyword">null</span>) || f == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 若是异步计算， 则尝试提交到线程池</span></span><br><span class="line">            <span class="keyword">if</span> (c != <span class="keyword">null</span> &amp;&amp; !c.claim())</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// 若前置阶段出现异常，将结果CAS更新</span></span><br><span class="line">            <span class="keyword">if</span> (r <span class="keyword">instanceof</span> AltResult &amp;&amp; (x = ((AltResult)r).ex) != <span class="keyword">null</span>)</span><br><span class="line">                completeThrowable(x, r);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 运行新的计算</span></span><br><span class="line">                f.run();</span><br><span class="line">                completeNull();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            completeThrowable(ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="OrRun"><a href="#OrRun" class="headerlink" title="OrRun"></a>OrRun</h3><p>OrRun类基础了Completion，抽象了Or关系，是栈上元素，记录了当前计算依赖的两个前置阶段，当前计算需要执行的线程池，计算过程。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">OrRun</span>&lt;<span class="title">T</span>,<span class="title">U</span>&gt; <span class="keyword">extends</span> <span class="title">BiCompletion</span>&lt;<span class="title">T</span>,<span class="title">U</span>,<span class="title">Void</span>&gt; </span>&#123;</span><br><span class="line">    Runnable fn;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *  <span class="doctag">@param</span> executor 任务执行的线程池</span></span><br><span class="line"><span class="comment">     *  <span class="doctag">@param</span> dep 当前计算依赖的阶段</span></span><br><span class="line"><span class="comment">     *  <span class="doctag">@param</span> src 前置计算</span></span><br><span class="line"><span class="comment">     *  <span class="doctag">@param</span> snd 另一个前置计算</span></span><br><span class="line"><span class="comment">     *  <span class="doctag">@param</span> fn 当前计算过程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    OrRun(Executor executor, CompletableFuture&lt;Void&gt; dep,</span><br><span class="line">          CompletableFuture&lt;T&gt; src,</span><br><span class="line">          CompletableFuture&lt;U&gt; snd,</span><br><span class="line">          Runnable fn) &#123;</span><br><span class="line">        <span class="keyword">super</span>(executor, dep, src, snd); <span class="keyword">this</span>.fn = fn;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> CompletableFuture&lt;Void&gt; <span class="title">tryFire</span><span class="params">(<span class="keyword">int</span> mode)</span> </span>&#123;</span><br><span class="line">        CompletableFuture&lt;Void&gt; d;</span><br><span class="line">        CompletableFuture&lt;T&gt; a;</span><br><span class="line">        CompletableFuture&lt;U&gt; b;</span><br><span class="line">        <span class="comment">// 尝试运行当前计算</span></span><br><span class="line">        <span class="keyword">if</span> ((d = dep) == <span class="keyword">null</span> ||</span><br><span class="line">            !d.orRun(a = src, b = snd, fn, mode &gt; <span class="number">0</span> ? <span class="keyword">null</span> : <span class="keyword">this</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        dep = <span class="keyword">null</span>; src = <span class="keyword">null</span>; snd = <span class="keyword">null</span>; fn = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 运行成功就清理阶段a，b上的栈元素</span></span><br><span class="line">        <span class="keyword">return</span> d.postFire(a, b, mode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Both-biRunStage"><a href="#Both-biRunStage" class="headerlink" title="Both - biRunStage"></a>Both - biRunStage</h2><p>等待两个阶段的任意一个完成后开始新的计算，思路和either相差不多,判断条件不一样<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title">runAfterBoth</span><span class="params">(CompletionStage&lt;?&gt; other,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            Runnable action)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> biRunStage(<span class="keyword">null</span>, other, action);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 执行AND关系的计算</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> a 前置的计算阶段</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o 另一个前置的计算阶段</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> f 执行的计算过程</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true 计算已经执行完；false 计算目前不能执行 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> CompletableFuture&lt;Void&gt; <span class="title">biRunStage</span><span class="params">(Executor e, CompletionStage&lt;?&gt; o,</span></span></span><br><span class="line"><span class="function"><span class="params">                                           Runnable f)</span> </span>&#123;</span><br><span class="line">    CompletableFuture&lt;?&gt; b;</span><br><span class="line">    <span class="comment">// 参数教验</span></span><br><span class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span> || (b = o.toCompletableFuture()) == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">// 新的计算阶段</span></span><br><span class="line">    CompletableFuture&lt;Void&gt; d = <span class="keyword">new</span> CompletableFuture&lt;Void&gt;();</span><br><span class="line">    <span class="comment">// 首先尝试一次计算</span></span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span> || !d.biRun(<span class="keyword">this</span>, b, f, <span class="keyword">null</span>)) &#123;</span><br><span class="line">        BiRun&lt;T,?&gt; c = <span class="keyword">new</span> BiRun&lt;&gt;(e, d, <span class="keyword">this</span>, b, f);</span><br><span class="line">        bipush(b, c);</span><br><span class="line">        c.tryFire(SYNC);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">biRun</span><span class="params">(CompletableFuture&lt;?&gt; a, CompletableFuture&lt;?&gt; b,</span></span></span><br><span class="line"><span class="function"><span class="params">                    Runnable f, BiRun&lt;?,?&gt; c)</span> </span>&#123;</span><br><span class="line">    Object r, s; Throwable x;</span><br><span class="line">    <span class="comment">// 阶段 a，b只要有一个没有完成，就返回false</span></span><br><span class="line">    <span class="keyword">if</span> (a == <span class="keyword">null</span> || (r = a.result) == <span class="keyword">null</span> ||</span><br><span class="line">        b == <span class="keyword">null</span> || (s = b.result) == <span class="keyword">null</span> || f == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 检查异常并CAS更新结果， a，b两阶段任意一个出现异常那么此阶段就是结果异常</span></span><br><span class="line">        <span class="keyword">if</span> (r <span class="keyword">instanceof</span> AltResult &amp;&amp; (x = ((AltResult)r).ex) != <span class="keyword">null</span>)</span><br><span class="line">            completeThrowable(x, r);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s <span class="keyword">instanceof</span> AltResult &amp;&amp; (x = ((AltResult)s).ex) != <span class="keyword">null</span>)</span><br><span class="line">            completeThrowable(x, s);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 尝试加入到线程池</span></span><br><span class="line">                <span class="keyword">if</span> (c != <span class="keyword">null</span> &amp;&amp; !c.claim())</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="comment">// 同步执行</span></span><br><span class="line">                f.run();</span><br><span class="line">                completeNull();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                completeThrowable(ex);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="BiRun"><a href="#BiRun" class="headerlink" title="BiRun"></a>BiRun</h3><p>描述一种线程关系，用于保存到栈上，当前计算需要等到两个计算都完成才开始，此类记录了当前计算依赖的两个前置阶段，当前计算需要执行的线程池，计算过程。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">BiRun</span>&lt;<span class="title">T</span>,<span class="title">U</span>&gt; <span class="keyword">extends</span> <span class="title">BiCompletion</span>&lt;<span class="title">T</span>,<span class="title">U</span>,<span class="title">Void</span>&gt; </span>&#123;</span><br><span class="line">    Runnable fn;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *  <span class="doctag">@param</span> executor 任务执行的线程池</span></span><br><span class="line"><span class="comment">     *  <span class="doctag">@param</span> dep 当前计算依赖的阶段</span></span><br><span class="line"><span class="comment">     *  <span class="doctag">@param</span> src 前置计算</span></span><br><span class="line"><span class="comment">     *  <span class="doctag">@param</span> snd 另一个前置计算</span></span><br><span class="line"><span class="comment">     *  <span class="doctag">@param</span> fn 当前计算过程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    BiRun(Executor executor, CompletableFuture&lt;Void&gt; dep,</span><br><span class="line">          CompletableFuture&lt;T&gt; src,</span><br><span class="line">          CompletableFuture&lt;U&gt; snd,</span><br><span class="line">          Runnable fn) &#123;</span><br><span class="line">        <span class="keyword">super</span>(executor, dep, src, snd); <span class="keyword">this</span>.fn = fn;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> CompletableFuture&lt;Void&gt; <span class="title">tryFire</span><span class="params">(<span class="keyword">int</span> mode)</span> </span>&#123;</span><br><span class="line">        CompletableFuture&lt;Void&gt; d;</span><br><span class="line">        CompletableFuture&lt;T&gt; a;</span><br><span class="line">        CompletableFuture&lt;U&gt; b;</span><br><span class="line">        <span class="comment">// 调用birun执行</span></span><br><span class="line">        <span class="keyword">if</span> ((d = dep) == <span class="keyword">null</span> ||</span><br><span class="line">            !d.biRun(a = src, b = snd, fn, mode &gt; <span class="number">0</span> ? <span class="keyword">null</span> : <span class="keyword">this</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        dep = <span class="keyword">null</span>; src = <span class="keyword">null</span>; snd = <span class="keyword">null</span>; fn = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 成功执行后清理a，b的栈</span></span><br><span class="line">        <span class="keyword">return</span> d.postFire(a, b, mode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Combine-biApplyStage"><a href="#Combine-biApplyStage" class="headerlink" title="Combine - biApplyStage"></a>Combine - biApplyStage</h2><p>Combine的执行和Both类似， 他们的区别是Combine是合并两个值，意味着Combine的两个前置阶段有返回值，并且交给Combine过程去处理然后产生新的值,而Both不接收或者接收一个值。首先看个接口<code>BiFunction</code></p>
<h3 id="BiFunction"><a href="#BiFunction" class="headerlink" title="BiFunction"></a>BiFunction</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 表示接受两个参数并生成结果的函数。 这是Function的双重特化。</span></span><br><span class="line"><span class="comment"> * 这是一个功能方法适用的功能接口apply(Object, Object)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt; 第一个参数的类型</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;U&gt; 第二个参数的类型</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;R&gt; 返回值类型</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> Function</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BiFunction</span>&lt;<span class="title">T</span>, <span class="title">U</span>, <span class="title">R</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用参数调用此方法，并且返回值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t 第一个参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> u 第二个参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">R <span class="title">apply</span><span class="params">(T t, U u)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回先将此函数应用于其输入的组合函数，然后将after函数应用于结果。 </span></span><br><span class="line"><span class="comment">     * 如果任一函数抛出异常，它将被转发给他组合函数的调用者。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;V&gt; after函数的输出类型和组合函数的输出类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> after  应用此功能后应用的功能</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 一个组合函数，首先应用此函数，然后应用after函数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException 若after为空抛出异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> &lt;V&gt; <span class="function">BiFunction&lt;T, U, V&gt; <span class="title">andThen</span><span class="params">(Function&lt;? <span class="keyword">super</span> R, ? extends V&gt; after)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(after);</span><br><span class="line">        <span class="keyword">return</span> (T t, U u) -&gt; after.apply(apply(t, u));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;U,V&gt; <span class="function">CompletableFuture&lt;V&gt; <span class="title">thenCombine</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    CompletionStage&lt;? extends U&gt; other,</span></span></span><br><span class="line"><span class="function"><span class="params">    BiFunction&lt;? <span class="keyword">super</span> T,? <span class="keyword">super</span> U,? extends V&gt; fn)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> biApplyStage(<span class="keyword">null</span>, other, fn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 执行AND关系的计算，即等待所有任务完成才能开始执行新的计算</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 计算执行的线程池，空表示同步执行</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o 另一个计算阶段，等待的对象就是当前计算阶段this和另一个计算阶段o</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> f 执行的计算过程，使用前两个阶段的计算结果并返回新的计算结果</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 新的CompeltabelFuture</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> &lt;U,V&gt; <span class="function">CompletableFuture&lt;V&gt; <span class="title">biApplyStage</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    Executor e, CompletionStage&lt;U&gt; o,</span></span></span><br><span class="line"><span class="function"><span class="params">    BiFunction&lt;? <span class="keyword">super</span> T,? <span class="keyword">super</span> U,? extends V&gt; f)</span> </span>&#123;</span><br><span class="line">    CompletableFuture&lt;U&gt; b;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span> || (b = o.toCompletableFuture()) == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">// 创建一个新的阶段</span></span><br><span class="line">    CompletableFuture&lt;V&gt; d = <span class="keyword">new</span> CompletableFuture&lt;V&gt;();</span><br><span class="line">    <span class="comment">// 尝试执行一次，若执行失败则入栈</span></span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span> || !d.biApply(<span class="keyword">this</span>, b, f, <span class="keyword">null</span>)) &#123;</span><br><span class="line">        BiApply&lt;T,U,V&gt; c = <span class="keyword">new</span> BiApply&lt;T,U,V&gt;(e, d, <span class="keyword">this</span>, b, f);</span><br><span class="line">        <span class="comment">// 入栈</span></span><br><span class="line">        bipush(b, c);</span><br><span class="line">        <span class="comment">// 再次尝试同步执行</span></span><br><span class="line">        c.tryFire(SYNC);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 执行AND关系的计算，即等待所有任务完成才能开始执行新的计算</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> a 前置计算阶段</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> b 另一个计算阶段，等待的对象就是当前计算阶段this和另一个计算阶段o</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> f 执行的计算过程，使用前两个阶段的计算结果并返回新的计算结果</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true 表示成功执行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> &lt;R,S&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">biApply</span><span class="params">(CompletableFuture&lt;R&gt; a,</span></span></span><br><span class="line"><span class="function"><span class="params">                            CompletableFuture&lt;S&gt; b,</span></span></span><br><span class="line"><span class="function"><span class="params">                            BiFunction&lt;? <span class="keyword">super</span> R,? <span class="keyword">super</span> S,? extends T&gt; f,</span></span></span><br><span class="line"><span class="function"><span class="params">                            BiApply&lt;R,S,T&gt; c)</span> </span>&#123;</span><br><span class="line">    Object r, s; Throwable x;</span><br><span class="line">    <span class="comment">// 检查，必须两个前置阶段都完成才能执行</span></span><br><span class="line">    <span class="keyword">if</span> (a == <span class="keyword">null</span> || (r = a.result) == <span class="keyword">null</span> ||</span><br><span class="line">        b == <span class="keyword">null</span> || (s = b.result) == <span class="keyword">null</span> || f == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 若当前阶段的result为空，表示当前阶段还未执行</span></span><br><span class="line">    <span class="comment">// 首先判断前置阶段1和前置阶段2的执行结果，任何一个异常都会导致当前计算异常</span></span><br><span class="line">    tryComplete: <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (r <span class="keyword">instanceof</span> AltResult) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((x = ((AltResult)r).ex) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                completeThrowable(x, r);</span><br><span class="line">                <span class="keyword">break</span> tryComplete;</span><br><span class="line">            &#125;</span><br><span class="line">            r = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s <span class="keyword">instanceof</span> AltResult) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((x = ((AltResult)s).ex) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                completeThrowable(x, s);</span><br><span class="line">                <span class="keyword">break</span> tryComplete;</span><br><span class="line">            &#125;</span><br><span class="line">            s = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 若是异步的计算就放入线程池</span></span><br><span class="line">            <span class="keyword">if</span> (c != <span class="keyword">null</span> &amp;&amp; !c.claim())</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) R rr = (R) r;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) S ss = (S) s;</span><br><span class="line">            <span class="comment">// 使用前两个阶段的值计算出新的值，并且CAS更新result</span></span><br><span class="line">            completeValue(f.apply(rr, ss));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            completeThrowable(ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 成功执行返回ture</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Compose-uniComposeStage"><a href="#Compose-uniComposeStage" class="headerlink" title="Compose - uniComposeStage"></a>Compose - uniComposeStage</h2><p>thenCompose 系列方法，这个系列的方法会新创建出一个子流程，最终结果和thenApply 系列是相同的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; <span class="title">thenCompose</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    Function&lt;? <span class="keyword">super</span> T, ? extends CompletionStage&lt;U&gt;&gt; fn)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> uniComposeStage(<span class="keyword">null</span>, fn);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 执行计算的线程池</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> f 计算过程，会返回一个子流程CompletionStage</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> &lt;V&gt; <span class="function">CompletableFuture&lt;V&gt; <span class="title">uniComposeStage</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    Executor e, Function&lt;? <span class="keyword">super</span> T, ? extends CompletionStage&lt;V&gt;&gt; f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    Object r; Throwable x;</span><br><span class="line">    <span class="comment">// 若当前阶段已完成计算</span></span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span> &amp;&amp; (r = result) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 若当前阶段结果异常，尝试直接返回函数结果</span></span><br><span class="line">        <span class="keyword">if</span> (r <span class="keyword">instanceof</span> AltResult) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((x = ((AltResult)r).ex) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> CompletableFuture&lt;V&gt;(encodeThrowable(x, r));</span><br><span class="line">            &#125;</span><br><span class="line">            r = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) T t = (T) r;</span><br><span class="line">            CompletableFuture&lt;V&gt; g = f.apply(t).toCompletableFuture();</span><br><span class="line">            Object s = g.result;</span><br><span class="line">            <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> CompletableFuture&lt;V&gt;(encodeRelay(s));</span><br><span class="line">            <span class="comment">// 建立一个新的阶段</span></span><br><span class="line">            CompletableFuture&lt;V&gt; d = <span class="keyword">new</span> CompletableFuture&lt;V&gt;();</span><br><span class="line">            <span class="comment">// 建立一个子流程的副本</span></span><br><span class="line">            UniRelay&lt;V&gt; copy = <span class="keyword">new</span> UniRelay&lt;V&gt;(d, g);</span><br><span class="line">            <span class="comment">// 将子流程的副本加入到子流程依赖阶段的栈中</span></span><br><span class="line">            g.push(copy);</span><br><span class="line">            <span class="comment">// 尝试执行一次副本</span></span><br><span class="line">            copy.tryFire(SYNC);</span><br><span class="line">            <span class="comment">// 返回新的阶段</span></span><br><span class="line">            <span class="keyword">return</span> d;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> CompletableFuture&lt;V&gt;(encodeThrowable(ex));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 没有完成计算，则将新的阶段压入当前阶段的栈</span></span><br><span class="line">    CompletableFuture&lt;V&gt; d = <span class="keyword">new</span> CompletableFuture&lt;V&gt;();</span><br><span class="line">    UniCompose&lt;T,V&gt; c = <span class="keyword">new</span> UniCompose&lt;T,V&gt;(e, d, <span class="keyword">this</span>, f);</span><br><span class="line">    <span class="comment">// 入栈</span></span><br><span class="line">    push(c);</span><br><span class="line">    <span class="comment">// 再次尝试调用</span></span><br><span class="line">    c.tryFire(SYNC);</span><br><span class="line">    <span class="comment">// 返回新的阶段</span></span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="UniRelay"><a href="#UniRelay" class="headerlink" title="UniRelay"></a>UniRelay</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">UniRelay</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">UniCompletion</span>&lt;<span class="title">T</span>,<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dep 新的阶段</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> src 计算返回的子流程阶段</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    UniRelay(CompletableFuture&lt;T&gt; dep, CompletableFuture&lt;T&gt; src) &#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="keyword">null</span>, dep, src);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> CompletableFuture&lt;T&gt; <span class="title">tryFire</span><span class="params">(<span class="keyword">int</span> mode)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 执行此子阶段</span></span><br><span class="line">        CompletableFuture&lt;T&gt; d; CompletableFuture&lt;T&gt; a;</span><br><span class="line">        <span class="comment">// 将子流程的阶段作为新阶段的前置阶段，然后执行子流程</span></span><br><span class="line">        <span class="keyword">if</span> ((d = dep) == <span class="keyword">null</span> || !d.uniRelay(a = src))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        src = <span class="keyword">null</span>; dep = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> d.postFire(a, mode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> a 计算返回的子流程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">uniRelay</span><span class="params">(CompletableFuture&lt;T&gt; a)</span> </span>&#123;</span><br><span class="line">    Object r;</span><br><span class="line">    <span class="comment">// 若子阶段未执行完成，返回false</span></span><br><span class="line">    <span class="keyword">if</span> (a == <span class="keyword">null</span> || (r = a.result) == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// 将新的流程的reslut CAS更新为子流程的计算结果</span></span><br><span class="line">        completeRelay(r);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 除非已经完成，否则用r或r的副本完成。 如果异常，则r首先被强制转换为CompletionException。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">completeRelay</span><span class="params">(Object r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, RESULT, <span class="keyword">null</span>,</span><br><span class="line">                                       encodeRelay(r));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><h3 id="exceptionally-uniExceptionallyStage"><a href="#exceptionally-uniExceptionallyStage" class="headerlink" title="exceptionally - uniExceptionallyStage"></a>exceptionally - uniExceptionallyStage</h3><p>此方法可以理解为try{}catch{}finally{}代码结构中的catch<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回在此CompletableFuture完成时完成的新CompletableFuture，给定函数fn在异常完成时触发此CompletableFuture;</span></span><br><span class="line"><span class="comment"> * 如果此CompletableFuture正常完成，则不会触发函数fn，返回的CompletableFuture也会以相同的值正常完成。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fn 如果此CompletableFuture异常完成，则用于计算返回的CompletableFuture的值的函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the new CompletableFuture</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;T&gt; <span class="title">exceptionally</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    Function&lt;Throwable, ? extends T&gt; fn)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> uniExceptionallyStage(fn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> f 阶段异常时触发的方法，参数是捕获的异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> CompletableFuture&lt;T&gt; <span class="title">uniExceptionallyStage</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    Function&lt;Throwable, ? extends T&gt; f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">// 建立一个新的阶段</span></span><br><span class="line">    CompletableFuture&lt;T&gt; d = <span class="keyword">new</span> CompletableFuture&lt;T&gt;();</span><br><span class="line">    <span class="comment">// 若存在异常情况则尝试触发</span></span><br><span class="line">    <span class="keyword">if</span> (!d.uniExceptionally(<span class="keyword">this</span>, f, <span class="keyword">null</span>)) &#123;</span><br><span class="line">        UniExceptionally&lt;T&gt; c = <span class="keyword">new</span> UniExceptionally&lt;T&gt;(d, <span class="keyword">this</span>, f);</span><br><span class="line">        push(c);</span><br><span class="line">        c.tryFire(SYNC);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> a 前置阶段</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> f 发生异常时触发的函数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">uniExceptionally</span><span class="params">(CompletableFuture&lt;T&gt; a,</span></span></span><br><span class="line"><span class="function"><span class="params">                               Function&lt;? <span class="keyword">super</span> Throwable, ? extends T&gt; f,</span></span></span><br><span class="line"><span class="function"><span class="params">                               UniExceptionally&lt;T&gt; c)</span> </span>&#123;</span><br><span class="line">    Object r; Throwable x;</span><br><span class="line">    <span class="comment">// 前置阶段还为完成，返回false</span></span><br><span class="line">    <span class="keyword">if</span> (a == <span class="keyword">null</span> || (r = a.result) == <span class="keyword">null</span> || f == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 如果前置阶段结果异常，则触发函数f</span></span><br><span class="line">            <span class="keyword">if</span> (r <span class="keyword">instanceof</span> AltResult &amp;&amp; (x = ((AltResult)r).ex) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (c != <span class="keyword">null</span> &amp;&amp; !c.claim())</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="comment">// 计算新的返回值</span></span><br><span class="line">                completeValue(f.apply(x));</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 若前置阶段结果没有异常， 则将前置阶段的结果CAS更新到新的阶段</span></span><br><span class="line">                internalComplete(r);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            completeThrowable(ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// CAS更新reslut</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">internalComplete</span><span class="params">(Object r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, RESULT, <span class="keyword">null</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="whenComplete-uniWhenCompleteStage"><a href="#whenComplete-uniWhenCompleteStage" class="headerlink" title="whenComplete - uniWhenCompleteStage"></a>whenComplete - uniWhenCompleteStage</h3><p>此方法可以理解为try{}catch{}finally{}代码结构中的finally<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> action 接收两个参数的计算，第一个参数为前置阶段的正常结果，第二个参数为前置阶段的异常结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;T&gt; <span class="title">whenComplete</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    BiConsumer&lt;? <span class="keyword">super</span> T, ? <span class="keyword">super</span> Throwable&gt; action)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> uniWhenCompleteStage(<span class="keyword">null</span>, action);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> CompletableFuture&lt;T&gt; <span class="title">uniWhenCompleteStage</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    Executor e, BiConsumer&lt;? <span class="keyword">super</span> T, ? <span class="keyword">super</span> Throwable&gt; f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">// 建立一个新的阶段</span></span><br><span class="line">    CompletableFuture&lt;T&gt; d = <span class="keyword">new</span> CompletableFuture&lt;T&gt;();</span><br><span class="line">    <span class="comment">// 尝试调用一次完成处理方法，若调用失败则入栈</span></span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span> || !d.uniWhenComplete(<span class="keyword">this</span>, f, <span class="keyword">null</span>)) &#123;</span><br><span class="line">        UniWhenComplete&lt;T&gt; c = <span class="keyword">new</span> UniWhenComplete&lt;T&gt;(e, d, <span class="keyword">this</span>, f);</span><br><span class="line">        push(c);</span><br><span class="line">        c.tryFire(SYNC);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> a 前置阶段</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> f 接收两个参数的计算，第一个参数为前置阶段的正常结果，第二个参数为前置阶段的异常结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">uniWhenComplete</span><span class="params">(CompletableFuture&lt;T&gt; a,</span></span></span><br><span class="line"><span class="function"><span class="params">                              BiConsumer&lt;? <span class="keyword">super</span> T,? <span class="keyword">super</span> Throwable&gt; f,</span></span></span><br><span class="line"><span class="function"><span class="params">                              UniWhenComplete&lt;T&gt; c)</span> </span>&#123;</span><br><span class="line">    Object r; T t; Throwable x = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 若前置阶段还未完成，则返回false</span></span><br><span class="line">    <span class="keyword">if</span> (a == <span class="keyword">null</span> || (r = a.result) == <span class="keyword">null</span> || f == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 若当前阶段未完成</span></span><br><span class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 尝试加入线程池</span></span><br><span class="line">            <span class="keyword">if</span> (c != <span class="keyword">null</span> &amp;&amp; !c.claim())</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// 若存在异常</span></span><br><span class="line">            <span class="keyword">if</span> (r <span class="keyword">instanceof</span> AltResult) &#123;</span><br><span class="line">                <span class="comment">// 则将异常取出</span></span><br><span class="line">                x = ((AltResult)r).ex;</span><br><span class="line">                t = <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) T tr = (T) r;</span><br><span class="line">                t = tr;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 调用计算过程</span></span><br><span class="line">            f.accept(t, x);</span><br><span class="line">            <span class="keyword">if</span> (x == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 将当前阶段的计算结果CAS更新为前置阶段的结算结果</span></span><br><span class="line">                <span class="comment">// 即计算结果保存不变</span></span><br><span class="line">                internalComplete(r);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x == <span class="keyword">null</span>)</span><br><span class="line">                x = ex;</span><br><span class="line">        &#125;</span><br><span class="line">        completeThrowable(x, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="handle-uniHandleStage"><a href="#handle-uniHandleStage" class="headerlink" title="handle - uniHandleStage"></a>handle - uniHandleStage</h3><p>handle的执行和whenComplete类似，他们的区别是handle可以返回新的执行结果，而whenComplete不可以。</p>
<h1 id="线程控制"><a href="#线程控制" class="headerlink" title="线程控制"></a>线程控制</h1><h2 id="取消-cancel"><a href="#取消-cancel" class="headerlink" title="取消 - cancel"></a>取消 - cancel</h2><p>取消操作本质上就是将reslut更新为<code>new AltResult(new CancellationException())</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果尚未完成，请使用CancellationException完成此CompletableFuture。 </span></span><br><span class="line"><span class="comment"> * 尚未完成的依赖CompletableFutures也将异常完成，</span></span><br><span class="line"><span class="comment"> * 并由此CancellationException引起CompletionException。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mayInterruptIfRunning  - 此值在此实现中无效，因为中断不用于控制处理。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 计算被取消返回true</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 更新result</span></span><br><span class="line">    <span class="keyword">boolean</span> cancelled = (result == <span class="keyword">null</span>) &amp;&amp;</span><br><span class="line">        internalComplete(<span class="keyword">new</span> AltResult(<span class="keyword">new</span> CancellationException()));</span><br><span class="line">    <span class="comment">// 唤醒此阶段栈上所有元素</span></span><br><span class="line">    postComplete();</span><br><span class="line">    <span class="comment">// 若设置值成功或者以及被取消返回ture</span></span><br><span class="line">    <span class="keyword">return</span> cancelled || isCancelled();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="阻塞-join"><a href="#阻塞-join" class="headerlink" title="阻塞 - join"></a>阻塞 - join</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 完成后返回结果值，如果异常完成则抛出（未经检查的）异常。 </span></span><br><span class="line"><span class="comment"> * 为了更好地符合常用函数形式的使用，如果完成此CompletableFuture所涉及的计算引发异常，</span></span><br><span class="line"><span class="comment"> * 则此方法将抛出（未经检查的）CompletionException，并将基础异常作为其原因。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 计算结果</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> CancellationException if the computation was cancelled</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> CompletionException if this future completed</span></span><br><span class="line"><span class="comment"> * exceptionally or a completion computation threw an exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">join</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Object r;</span><br><span class="line">    <span class="keyword">return</span> reportJoin((r = result) == <span class="keyword">null</span> ? waitingGet(<span class="keyword">false</span>) : r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="设置计算结果"><a href="#设置计算结果" class="headerlink" title="设置计算结果"></a>设置计算结果</h1><h2 id="complete"><a href="#complete" class="headerlink" title="complete"></a>complete</h2><p>此方法会传入一个值，若该阶段在调用此方法前还未完成，那么就将此值作为该阶段的计算结果，因为CAS更新了reslut，所以后面就算该阶段完成，值也不会更新了，此方法只能调用一次，重复调用不会生效。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果该阶段尚未完成，就将get（）和相关方法返回的值设置为给定值。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 返回值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 如果此调用导致此CompletableFuture转换为已完成状态，则返回true，否则返回false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">complete</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// CAS 更新result</span></span><br><span class="line">    <span class="keyword">boolean</span> triggered = completeValue(value);</span><br><span class="line">    <span class="comment">// 唤醒在该阶段栈上等待的所有计算</span></span><br><span class="line">    postComplete();</span><br><span class="line">    <span class="comment">// CAS更新成功，返回true</span></span><br><span class="line">    <span class="keyword">return</span> triggered;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="obtrudeValue"><a href="#obtrudeValue" class="headerlink" title="obtrudeValue"></a>obtrudeValue</h2><p>该方法作用和complete相同，但是调用该方法时，无论计算是否完成，都会更新为指定的值，并且可以重复调用。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 无论此阶段是否已经完成，强制设置或重置方法get（）和相关方法随后返回的值。 </span></span><br><span class="line"><span class="comment"> * 此方法仅用于错误恢复操作，即使在这种情况下，也可能导致使用已建立与已覆盖结果的完后后续的阶段。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 指定该阶段的计算结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">obtrudeValue</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 直接更新result</span></span><br><span class="line">    result = (value == <span class="keyword">null</span>) ? NIL : value;</span><br><span class="line">    <span class="comment">// 唤醒此阶段栈上所有计算</span></span><br><span class="line">    postComplete();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="completeExceptionally"><a href="#completeExceptionally" class="headerlink" title="completeExceptionally"></a>completeExceptionally</h2><p>此方法会传入一个异常，若该阶段在调用此方法前还未完成，那么就将此异常作为该阶段的计算结果，因为CAS更新了reslut，所以后面就算该阶段完成，值也不会更新了，此方法只能调用一次，重复调用不会生效。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果尚未完成，调用get（）和相关方法则会抛出给定的异常。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ex 指定抛出的异常</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 如果此调用导致此CompletableFuture转换为已完成状态，则返回true，否则返回false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">completeExceptionally</span><span class="params">(Throwable ex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 参数检查</span></span><br><span class="line">    <span class="keyword">if</span> (ex == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">// 将计算结果封装为异常，cas更新</span></span><br><span class="line">    <span class="keyword">boolean</span> triggered = internalComplete(<span class="keyword">new</span> AltResult(ex));</span><br><span class="line">    <span class="comment">// 唤醒栈上所有计算</span></span><br><span class="line">    postComplete();</span><br><span class="line">    <span class="comment">// 设置成功返回true</span></span><br><span class="line">    <span class="keyword">return</span> triggered;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="obtrudeException"><a href="#obtrudeException" class="headerlink" title="obtrudeException"></a>obtrudeException</h2><p>该方法作用和completeExceptionally相同，但是调用该方法时，无论计算是否完成，都会更新为指定的异常，并且可以重复调用。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 无论此阶段是否已经完成，强制设置或重置方法get（）和相关方法随后返回的异常。 </span></span><br><span class="line"><span class="comment"> * 此方法仅用于错误恢复操作，即使在这种情况下，也可能导致使用已建立与已覆盖结果的完后后续的阶段。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ex 指定该阶段的计算异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">obtrudeException</span><span class="params">(Throwable ex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 参数检查</span></span><br><span class="line">    <span class="keyword">if</span> (ex == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">// 将计算结果更新为指定异常</span></span><br><span class="line">    result = <span class="keyword">new</span> AltResult(ex);</span><br><span class="line">    <span class="comment">// 唤醒栈上所有计算</span></span><br><span class="line">    postComplete();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="get系列"><a href="#get系列" class="headerlink" title="get系列"></a>get系列</h1><h2 id="get"><a href="#get" class="headerlink" title="get"></a>get</h2><p>get方法用于获取该阶段的计算结果，和join类似，但是get方法会响应中断，而join不会响应中断<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 等待此阶段完成，获取计算结果</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 计算结果</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> CancellationException 被取消</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ExecutionException 计算执行异常</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> InterruptedException 被中断</span></span><br><span class="line"><span class="comment"> * while waiting</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">    Object r;</span><br><span class="line">    <span class="comment">// 调用此方法的时机存在两种情况</span></span><br><span class="line">    <span class="comment">// 1. 此时计算已经完成 reportGet(r)</span></span><br><span class="line">    <span class="comment">// 2. 此时计算未完成 reportGet(waitingGet(true))</span></span><br><span class="line">    <span class="keyword">return</span> reportGet((r = result) == <span class="keyword">null</span> ? waitingGet(<span class="keyword">true</span>) : r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用Future.get()的方式获取结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">reportGet</span><span class="params">(Object r)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">    <span class="comment">// 按照惯例，null表示中断</span></span><br><span class="line">    <span class="keyword">if</span> (r == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">if</span> (r <span class="keyword">instanceof</span> AltResult) &#123;</span><br><span class="line">        Throwable x, cause;</span><br><span class="line">        <span class="comment">// 异常结果处理</span></span><br><span class="line">        <span class="keyword">if</span> ((x = ((AltResult)r).ex) == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (x <span class="keyword">instanceof</span> CancellationException)</span><br><span class="line">            <span class="keyword">throw</span> (CancellationException)x;</span><br><span class="line">        <span class="keyword">if</span> ((x <span class="keyword">instanceof</span> CompletionException) &amp;&amp;</span><br><span class="line">            (cause = x.getCause()) != <span class="keyword">null</span>)</span><br><span class="line">            x = cause;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ExecutionException(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回正常计算结果</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) T t = (T) r;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 等待后返回原始结果，如果中断则返回null。</span></span><br><span class="line"><span class="comment"> * get的线程也同样时基于栈的等待</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">waitingGet</span><span class="params">(<span class="keyword">boolean</span> interruptible)</span> </span>&#123;</span><br><span class="line">    Signaller q = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> queued = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> spins = -<span class="number">1</span>;</span><br><span class="line">    Object r;</span><br><span class="line">    <span class="comment">// 循环判断是否执行完成</span></span><br><span class="line">    <span class="comment">// 当result ！= null 表示执行完成</span></span><br><span class="line">    <span class="keyword">while</span> ((r = result) == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (spins &lt; <span class="number">0</span>)</span><br><span class="line">            spins = (Runtime.getRuntime().availableProcessors() &gt; <span class="number">1</span>) ?</span><br><span class="line">                <span class="number">1</span> &lt;&lt; <span class="number">8</span> : <span class="number">0</span>; <span class="comment">// 在多处理器上使用简短的自旋等待</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (spins &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ThreadLocalRandom.nextSecondarySeed() &gt;= <span class="number">0</span>)</span><br><span class="line">                --spins;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (q == <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">// 将等待结果的线程封装为一个Signaller，然后进行下一次循环判断</span></span><br><span class="line">            <span class="comment">// Signaller继承了Completion，因此可以入栈</span></span><br><span class="line">            q = <span class="keyword">new</span> Signaller(interruptible, <span class="number">0L</span>, <span class="number">0L</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!queued)</span><br><span class="line">            <span class="comment">// 将Signaller入栈</span></span><br><span class="line">            queued = tryPushStack(q);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (interruptible &amp;&amp; q.interruptControl &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 若被中断，则唤醒栈上所有计算</span></span><br><span class="line">            q.thread = <span class="keyword">null</span>;</span><br><span class="line">            cleanStack();</span><br><span class="line">            <span class="comment">// 返回null</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (q.thread != <span class="keyword">null</span> &amp;&amp; result == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ForkJoinPool.managedBlock(q);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                q.interruptControl = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (q != <span class="keyword">null</span>) &#123;</span><br><span class="line">        q.thread = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (q.interruptControl &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (interruptible)</span><br><span class="line">                r = <span class="keyword">null</span>; <span class="comment">// report interruption</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    postComplete();</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="get-long-timeout-TimeUnit-unit"><a href="#get-long-timeout-TimeUnit-unit" class="headerlink" title="get(long timeout, TimeUnit unit)"></a>get(long timeout, TimeUnit unit)</h2><p>效果和get()相同，会有超时。超时会抛出TimeoutException</p>
<h2 id="getNow-T-valueIfAbsent"><a href="#getNow-T-valueIfAbsent" class="headerlink" title="getNow(T valueIfAbsent)"></a>getNow(T valueIfAbsent)</h2><p>立刻获取计算结果， 若计算未完成不会等待，而是使用指定的值作为计算结果返回，此方法不会影响该阶段继续计算，因此两次调用getNow方法的返回结果可能不一样。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果已完成，则返回结果值（或抛出任何遇到的异常），否则返回给定的valueIfAbsent。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> valueIfAbsent 如果没完成的返回值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the result value, if completed, else the given valueIfAbsent</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> CancellationException 被取消</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> CompletionException if this future completed</span></span><br><span class="line"><span class="comment"> * exceptionally or a completion computation threw an exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">getNow</span><span class="params">(T valueIfAbsent)</span> </span>&#123;</span><br><span class="line">    Object r;</span><br><span class="line">    <span class="keyword">return</span> ((r = result) == <span class="keyword">null</span>) ? valueIfAbsent : reportJoin(r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解码结果以返回结果或抛出未经检查的异常。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">reportJoin</span><span class="params">(Object r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (r <span class="keyword">instanceof</span> AltResult) &#123;</span><br><span class="line">        Throwable x;</span><br><span class="line">        <span class="comment">// 异常处理</span></span><br><span class="line">        <span class="keyword">if</span> ((x = ((AltResult)r).ex) == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (x <span class="keyword">instanceof</span> CancellationException)</span><br><span class="line">            <span class="keyword">throw</span> (CancellationException)x;</span><br><span class="line">        <span class="keyword">if</span> (x <span class="keyword">instanceof</span> CompletionException)</span><br><span class="line">            <span class="keyword">throw</span> (CompletionException)x;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> CompletionException(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) T t = (T) r;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="getNumberOfDependents"><a href="#getNumberOfDependents" class="headerlink" title="getNumberOfDependents"></a>getNumberOfDependents</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回依赖此阶段的计算个数，stack的数量</span></span><br><span class="line"><span class="comment"> * 此方法设计用于监视系统状态，而不是用于同步控制。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the number of dependent CompletableFutures</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumberOfDependents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 对栈循环计数</span></span><br><span class="line">    <span class="keyword">for</span> (Completion p = stack; p != <span class="keyword">null</span>; p = p.next)</span><br><span class="line">        ++count;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="状态判断"><a href="#状态判断" class="headerlink" title="状态判断"></a>状态判断</h1><h2 id="isDone"><a href="#isDone" class="headerlink" title="isDone"></a>isDone</h2><p>判断计算是否完成，result不为空就表示计算完成，注意此时计算完成并不代表线程已结束。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> result != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="isCancelled"><a href="#isCancelled" class="headerlink" title="isCancelled"></a>isCancelled</h2><p>判断是否被取消，根据result的结果判断，若结果是AltResult并且ex属性为CancellationException，那么就是被取消<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Object r;</span><br><span class="line">    <span class="keyword">return</span> ((r = result) <span class="keyword">instanceof</span> AltResult) &amp;&amp;</span><br><span class="line">        (((AltResult)r).ex <span class="keyword">instanceof</span> CancellationException);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="isCompletedExceptionally"><a href="#isCompletedExceptionally" class="headerlink" title="isCompletedExceptionally"></a>isCompletedExceptionally</h2><p>判断计算是否<strong>异常</strong>完成，根据result的结果判断，如果结果是AltResult并且不是NIL，那么就是异常<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCompletedExceptionally</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Object r;</span><br><span class="line">    <span class="keyword">return</span> ((r = result) <span class="keyword">instanceof</span> AltResult) &amp;&amp; r != NIL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/mynote/tags/java/" rel="tag"># java</a>
          
            <a href="/mynote/tags/juc/" rel="tag"># juc</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/mynote/2019/05/19/completionStage/" rel="next" title="CompletionStage">
                <i class="fa fa-chevron-left"></i> CompletionStage
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/mynote/2019/06/07/countDownLatch/" rel="prev" title="CountDownLatch">
                CountDownLatch <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">哩厘理濿</p>
              <div class="site-description motion-element" itemprop="description"></div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/mynote/archives/">
                
                    <span class="site-state-item-count">18</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">8</span>
                    <span class="site-state-item-name">tags</span>
                  
                </div>
              
            </nav>
          

          

          

          

          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#java-util-concurrent-CompletableFuture"><span class="nav-number">1.</span> <span class="nav-text">java.util.concurrent.CompletableFuture</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#源码功能概览："><span class="nav-number">1.1.</span> <span class="nav-text">源码功能概览：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#属性"><span class="nav-number">1.2.</span> <span class="nav-text">属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#标识接口"><span class="nav-number">1.3.</span> <span class="nav-text">标识接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#空置和异常"><span class="nav-number">1.4.</span> <span class="nav-text">空置和异常</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#栈-Completion"><span class="nav-number">1.5.</span> <span class="nav-text">栈 - Completion</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#实例化"><span class="nav-number">2.</span> <span class="nav-text">实例化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#runAsync"><span class="nav-number">2.1.</span> <span class="nav-text">runAsync</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#AsyncRun"><span class="nav-number">2.1.1.</span> <span class="nav-text">AsyncRun</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#supplyAsync"><span class="nav-number">2.2.</span> <span class="nav-text">supplyAsync</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#AsyncSupply"><span class="nav-number">2.2.1.</span> <span class="nav-text">AsyncSupply</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#completedFuture"><span class="nav-number">2.3.</span> <span class="nav-text">completedFuture</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#anyOf"><span class="nav-number">2.4.</span> <span class="nav-text">anyOf</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#allOf"><span class="nav-number">2.5.</span> <span class="nav-text">allOf</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#线程间的关系"><span class="nav-number">3.</span> <span class="nav-text">线程间的关系</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#then-uniRunStage"><span class="nav-number">3.1.</span> <span class="nav-text">then - uniRunStage</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#UniRun"><span class="nav-number">3.1.1.</span> <span class="nav-text">UniRun</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Either-orRunStage"><span class="nav-number">3.2.</span> <span class="nav-text">Either - orRunStage</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#OrRun"><span class="nav-number">3.2.1.</span> <span class="nav-text">OrRun</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Both-biRunStage"><span class="nav-number">3.3.</span> <span class="nav-text">Both - biRunStage</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#BiRun"><span class="nav-number">3.3.1.</span> <span class="nav-text">BiRun</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Combine-biApplyStage"><span class="nav-number">3.4.</span> <span class="nav-text">Combine - biApplyStage</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#BiFunction"><span class="nav-number">3.4.1.</span> <span class="nav-text">BiFunction</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Compose-uniComposeStage"><span class="nav-number">3.5.</span> <span class="nav-text">Compose - uniComposeStage</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#UniRelay"><span class="nav-number">3.5.1.</span> <span class="nav-text">UniRelay</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#异常处理"><span class="nav-number">3.6.</span> <span class="nav-text">异常处理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#exceptionally-uniExceptionallyStage"><span class="nav-number">3.6.1.</span> <span class="nav-text">exceptionally - uniExceptionallyStage</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#whenComplete-uniWhenCompleteStage"><span class="nav-number">3.6.2.</span> <span class="nav-text">whenComplete - uniWhenCompleteStage</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#handle-uniHandleStage"><span class="nav-number">3.6.3.</span> <span class="nav-text">handle - uniHandleStage</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#线程控制"><span class="nav-number">4.</span> <span class="nav-text">线程控制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#取消-cancel"><span class="nav-number">4.1.</span> <span class="nav-text">取消 - cancel</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#阻塞-join"><span class="nav-number">4.2.</span> <span class="nav-text">阻塞 - join</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#设置计算结果"><span class="nav-number">5.</span> <span class="nav-text">设置计算结果</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#complete"><span class="nav-number">5.1.</span> <span class="nav-text">complete</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#obtrudeValue"><span class="nav-number">5.2.</span> <span class="nav-text">obtrudeValue</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#completeExceptionally"><span class="nav-number">5.3.</span> <span class="nav-text">completeExceptionally</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#obtrudeException"><span class="nav-number">5.4.</span> <span class="nav-text">obtrudeException</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#get系列"><span class="nav-number">6.</span> <span class="nav-text">get系列</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#get"><span class="nav-number">6.1.</span> <span class="nav-text">get</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#get-long-timeout-TimeUnit-unit"><span class="nav-number">6.2.</span> <span class="nav-text">get(long timeout, TimeUnit unit)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#getNow-T-valueIfAbsent"><span class="nav-number">6.3.</span> <span class="nav-text">getNow(T valueIfAbsent)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#getNumberOfDependents"><span class="nav-number">6.4.</span> <span class="nav-text">getNumberOfDependents</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#状态判断"><span class="nav-number">7.</span> <span class="nav-text">状态判断</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#isDone"><span class="nav-number">7.1.</span> <span class="nav-text">isDone</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#isCancelled"><span class="nav-number">7.2.</span> <span class="nav-text">isCancelled</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#isCompletedExceptionally"><span class="nav-number">7.3.</span> <span class="nav-text">isCompletedExceptionally</span></a></li></ol></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">哩厘理濿</span><br>
<img alt="知识共享许可协议" style="border-width:0;display:inline" src="https://i.creativecommons.org/l/by-nc/4.0/80x15.png">
本作品采用<a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可。
  

  
</div>


        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  

  

  
</div>









        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/mynote/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/mynote/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/mynote/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/mynote/js/utils.js?v=7.1.0"></script>

  <script src="/mynote/js/motion.js?v=7.1.0"></script>



  
  


  <script src="/mynote/js/schemes/muse.js?v=7.1.0"></script>




  
  <script src="/mynote/js/scrollspy.js?v=7.1.0"></script>
<script src="/mynote/js/post-details.js?v=7.1.0"></script>



  


  <script src="/mynote/js/next-boot.js?v=7.1.0"></script>


  

  

  

  


  


  




  

  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
